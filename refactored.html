<!DOCTYPE html>
<html>

<head>
  <script src="https://unpkg.com/konva@4.0.3/konva.min.js"></script>
  <meta charset="utf-8" />
  <title>Konva Simple Window drawing</title>
  <style>
    body {
      PADDING: 0;
      margin: 0;
      overflow: hidden;
    }

    #container {
      /* border: 1px solid grey; */
      /* background-color: lightgrey; */
      background-color: #fff;
    }

    #controls {
      position: absolute;
      top: 4px;
      left: 4px;
    }
  </style>
</head>

<body>
  <div id="container"></div>

  <div id="controls">
    <div style="float: left; PADDING: 10px">
      Length:
      <input type="number" id="widthInput" />
    </div>
    <div style="float: left; PADDING: 10px">
      Width:
      <input type="number" id="heightInput" />
    </div>
  </div>
  <script>

    // Constants
    const SCALE_FACTOR = 0.65;
    // const PADDING = 70; // mm

    // planter dimensions
    var PLANTER_WIDTH = 160;
    var PLANTER_LENGTH = 800;
    var PRIVACY_WIDTH = 45;
    var PRIVACY_LENGTH = PLANTER_LENGTH;


    class Corner extends Konva.Rect {

      constructor(x, y, width) {
        // Konva.Rect
        super({
          x: x,
          y: y,
          width: width,
          height: width,
          fill: 'white',
          stroke: 'black',
          strokeWidth: 1
        });
      }
    }

    class Railing extends Konva.Rect {

      constructor(canvas, x, y, width, height, position) {
        super({
          x: x,
          y: y,
          width: width,
          height: height,
          fill: '#EAEAEA',
          stroke: 'black',
          strokeWidth: 1
        });

        this.canvas = canvas;

        this.position = position;
        this.centreX = x + width / 2;
        this.centreY = y + height / 2;

        this.hasPlanter = false;

        this.addEventListeners();
      }

      addEventListeners() {
        this.on('mouseenter', function () {
          canvas.eventMouseenterRailing(this);
        })
        this.on('mouseleave', function () {
          canvas.eventMouseleaveRailing(this);
        })
      }
    }

    class Planter extends Konva.Rect {

      constructor(railing) {

        let x, y, width, height;

        if (railing.position === 'top') {
            x = railing.centreX - PLANTER_LENGTH / 2;
            y = railing.centreY - railing.getHeight() / 2 - PLANTER_WIDTH;
            width = PLANTER_LENGTH;
            height = PLANTER_WIDTH;
        } else if (railing.position === 'bottom') {
            x = railing.centreX - PLANTER_LENGTH / 2;
            y = railing.centreY + railing.getHeight() / 2;
            width = PLANTER_LENGTH;
            height =PLANTER_WIDTH;
        } else if (railing.position === 'left') {
            x = railing.centreX - PLANTER_WIDTH - railing.getWidth() / 2;
            y = railing.centreY - PLANTER_LENGTH / 2;
            width = PLANTER_WIDTH;
            height = PLANTER_LENGTH;
        } else if (railing.position === 'right') {
            x = railing.centreX + railing.getWidth() / 2;
            y = railing.centreY - PLANTER_LENGTH / 2;
            width = PLANTER_WIDTH;
            height = PLANTER_LENGTH;
        }

        super({
          x: x,
          y: y,
          width: width,
          height: height,
          fill: '#a3c2c2',
          stroke: 'black',
          strokeWidth: 1
        })

        this.isSelected = false;
        this.hover = false;
        this.railingId = railing._id;

        this.addEventListeners();
      }

      addEventListeners() {
        this.on('click', function () {
          console.log('Planter.click');
          canvas.eventClickPlanter(this);
        })
        this.on('mouseenter', function () {
          canvas.eventMouseenterPlanter(this);
        })
        this.on('mouseleave', function () {
          canvas.eventMouseleavePlanter(this);
        })
      }
    }

    class Privacy extends Konva.Rect {

      constructor(railing) {

        let x, y, width, height

        if (railing.position === 'top') {
            x = railing.centreX - PRIVACY_LENGTH / 2;
            y = railing.centreY + railing.getHeight() / 2;
            width = PLANTER_LENGTH;
            height = PRIVACY_WIDTH;
        } else if (railing.position === 'bottom') {
            x = railing.centreX - PRIVACY_LENGTH / 2;
            y = railing.centreY - railing.getHeight() / 2 - PRIVACY_WIDTH;
            width = PLANTER_LENGTH;
            height =PRIVACY_WIDTH;
        } else if (railing.position === 'left') {
            // x = railing.centreX + railing.getWidth() - PRIVACY_WIDTH / 2;
            x = railing.centreX + railing.getWidth() / 2;
            y = railing.centreY - PRIVACY_LENGTH / 2;
            width = PRIVACY_WIDTH;
            height = PLANTER_LENGTH;
        } else if (railing.position === 'right') {
            x = railing.centreX - railing.getWidth() / 2 - PRIVACY_WIDTH;
            y = railing.centreY - PRIVACY_LENGTH / 2;
            width = PRIVACY_WIDTH;
            height = PLANTER_LENGTH;
        }

        super({
          x: x,
          y: y,
          width: width,
          height: height,
          fill: '#73264d',
          stroke: 'black',
          strokeWidth: 1
        })

        this.isSelected = false;
        this.hover = false;
        this.railingId = railing._id;

        this.addEventListeners();
      }

      addEventListeners() {
        this.on('click', function () {
          console.log('Planter.click');
          canvas.eventClickPrivacy(this);
        });
        this.on('mouseenter', function () {
          canvas.eventMouseenterPrivacy(this);
        });
        this.on('mouseleave', function () {
          canvas.eventMouseleavePrivacy(this);
        });
      }
    }

    class Canvas {

      PAD = 70;

      // parameters
      windowWidth;
      windowHeight;
      balconyWidth;
      balconyHeight;

      constructor() {

        // Canvas dimensions
        this.getWindowDimensions();
        // Get the balcony dimensions
        this.getBalconyDimensions();

        // Create the stage
        this.stage = new Konva.Stage({
          container: 'container',
          width: this.windowWidth,
          height: this.windowHeight
        });

        // Create the layer, and add it to the stage
        this.layer = new Konva.Layer();
        this.stage.add(this.layer);

        // Corners
        // this.cornerGroup = new Konva.Group();
        this.corners = [];

        // Railings 
        this.railings = []
        // Planters
        this.planters = {}; // id: Planter (Konva.Rect)
        this.privacies = {};

        this.isInitialized = false;
      }

      getWindowDimensions() {
        // Canvas dimensions
        this.windowWidth = window.innerWidth;
        this.windowHeight = window.innerHeight;
        //  console.log('Window: ', this.windowWidth, this.windowHeight);
      }

      getBalconyDimensions() {
        var urlParams = new URLSearchParams(window.location.search);
        this.balconyHeight = parseInt(urlParams.get('length'));
        this.balconyWidth = parseInt(urlParams.get('width'));
        console.log('Balcony: ', this.balconyWidth, this.balconyHeight);

      }

      render() {
        if (!this.isInitialized) {
          this.initCanvas();
        } else {
          this.updateCanvas();
        }

      }

      initCanvas() {
        console.log("initCanvas")
        this.layer.children.destroy();

        this.ratio = this.calculateWindowRatio();

        // Create base group and add it to stage.layer
        this.baseGroup = this.createBaseGroup();
        this.layer.add(this.baseGroup);

        // Corners
        let cornerGroup = this.createCorners();
        this.baseGroup.add(cornerGroup);

        // railings
        let frameGroup = this.createFrames();
        this.baseGroup.add(frameGroup);

        // planters
        this.planterGroup = new Konva.Group();
        this.planterGroup.scale({x: this.ratio, y: this.ratio});
        this.baseGroup.add(this.planterGroup);
        // debug only
        // this.createPlanters();

        this.privacyGroup = new Konva.Group();
        this.privacyGroup.scale({x: this.ratio, y: this.ratio});
        this.baseGroup.add(this.privacyGroup);
        // debug only
        // this.createPrivacy();

        this.isinitialize = true;

        this.layer.draw();
      }

      updateCanvas() {
        // console.log('updateCanvas');
        this.layer.draw();
      }

      calculateWindowRatio() {
        let wr = this.stage.width() / this.balconyWidth;
        let hr = this.stage.height() / this.balconyHeight;
        return Math.min(wr, hr) * SCALE_FACTOR;
      }

      createBaseGroup() {
        let frameOnScreenWidth = this.balconyWidth * this.ratio;
        let frameOnScreenHeight = this.balconyHeight * this.ratio;

        var group = new Konva.Group({});

        group.x(Math.round(this.stage.width() / 2 - frameOnScreenWidth / 2) + 0.5);
        group.y(Math.round(this.stage.height() / 2 - frameOnScreenHeight / 2) + 0.5);
        return group;
      }

      createCorners() {

        // Create the corners
        let topLeft = new Corner(0, 0, this.PAD);
        let topRight = new Corner(this.balconyWidth - this.PAD, 0, this.PAD);
        let bottomLeft = new Corner(0, this.balconyHeight - this.PAD, this.PAD);
        let bottomRight = new Corner(this.balconyWidth - this.PAD, this.balconyHeight - this.PAD, this.PAD);

        this.corners.push(topLeft);
        this.corners.push(topRight);
        this.corners.push(bottomLeft);
        this.corners.push(bottomRight);

        let cornerGroup = new Konva.Group();
        cornerGroup.add(topLeft, topRight, bottomLeft, bottomRight);
        cornerGroup.scale({ x: this.ratio, y: this.ratio });

        return cornerGroup;
      }

      createPlanters() {
        this.railings.forEach(railing => {
          let planter = new Planter(railing);
          this.planterGroup.add(planter);
          this.planters[railing._id] = planter;
        })
        this.planterGroup.scale({x: this.ratio, y: this.ratio});
      }

      createPrivacy() {
        this.railings.forEach(railing => {
          let privacy = new Privacy(railing);
          this.privacyGroup.add(privacy);
          this.privacies[railing._id] = privacy;
          console.log('added privacy to privacies', privacy, this.privacies);
        })
        this.planterGroup.scale({x: this.ratio, y: this.ratio});
      }

      createFrames() {

        let group = new Konva.Group();

        group.add(this.createWidthFrames());
        group.add(this.createHeightFrames());
        group.scale({ x: this.ratio, y: this.ratio });

        return group;
      }

      createWidthFrames() {

        let frameWidth = this.balconyWidth;
        let frameHeight = this.balconyHeight;

        var group = new Konva.Group();

        var topDim = frameWidth - (2 * this.PAD);
        var numSections = Math.floor(topDim / PLANTER_LENGTH);
        var remainder = topDim % (numSections * PLANTER_LENGTH)
        var sectionLength = remainder / numSections + PLANTER_LENGTH;

        for (let i = 0; i < numSections; i++) {

          let xOffset = this.PAD + (i * sectionLength);

          let top = new Railing(this, xOffset, 0, sectionLength, this.PAD, 'top');
          let bottom = new Railing(this, xOffset, this.balconyHeight - this.PAD, sectionLength, this.PAD, 'bottom');

          this.railings.push(top);
          this.railings.push(bottom);

          group.add(top, bottom);
        }

        return group;
      }

      createHeightFrames() {

        var group = new Konva.Group();

        // Some vars for easy calculations -  need numSections, and sectionLength
        var sideDim = this.balconyHeight - 2 * this.PAD;
        var numSections = Math.floor(sideDim / PLANTER_LENGTH);
        var remainder = sideDim % (numSections * PLANTER_LENGTH)
        var sectionLength = remainder / numSections + PLANTER_LENGTH;

        for (let i = 0; i < numSections; i++) {

          let yOffset = this.PAD + (i * sectionLength);

          // Left and Right section
          let left = new Railing(this, 0, yOffset, this.PAD, sectionLength, 'left');
          let right = new Railing(this, this.balconyWidth - this.PAD, yOffset, this.PAD, sectionLength, 'right');

          // Add to the railings array
          this.railings.push(left);
          this.railings.push(right);

          // Add to group
          group.add(left, right);
        }

        return group;
      }

      eventMouseenterRailing(railing) {
        // console.log('eventMouseenterRailing', railing);

        if (!railing.hasPlanter) {

          this.addAllPlantersToTree(railing);
          // // Planters
          // let planter = new Planter(railing);
          // this.planterGroup.add(planter);
          // this.planters[railing._id] = planter;

          // // Privacies
          // let privacy = new Privacy(railing);
          // this.privacyGroup.add(privacy);
          // this.privacies[railing._id] = privacy;
          // console.log('added privacy to privacies', privacy, this.privacies);

          this.updateCanvas();
        }
        railing.hasPlanter = true;
      }

      addAllPlantersToTree(railing) {
        console.log('addAllPlantersToTree')
      }

      eventMouseleaveRailing(railing) {

          // Planter timeout
          this.planterTimeout = setTimeout((railing) => {
            let planter = this.planters[railing._id];
            if (planter === undefined) console.log('ERR: Planter not Defined');

            if (!planter.hover) {
              // console.log('removingPlanter');
              this.removePlanter(railing);
            }
          }, 200, railing);

          // Privacy timeout
          this.privacyTimeout = setTimeout((railing) => {
            let privacy = this.privacies[railing._id];
            if (privacy === undefined) console.log('ERR: Privacy not Defined', this.privacies)

            if (!privacy.hover) {
              this.removePrivacy(railing);
            }
          }, 200, railing);
      }

      removePlanter(railing) {
        let planter = this.planters[railing._id];

        if (planter.isSelected) {
          return;
        }

        // Remove planter from this.planters
        if (!planter.isSelected) {
          planter.destroy();
          delete this.planters[railing._id];
        }

        railing.hasPlanter = false;
        this.updateCanvas();
      }

      removePrivacy(railing) {
        if (railing === undefined) console.log('removePrivacy ERR: railing undefined');
        let privacy = this.privacies[railing._id];
        if (privacy === undefined) console.log('ERR: Privacy not Defined', this.privacies)


        if (privacy.isSelected) {
          return;
        }

        // Remove privacy from this.planters
        console.log(this.privacies);
        throw new Error('deleting privacy from privacies', this.privacies);
        privacy.destroy();
        delete this.privacies[railing._id];
        console.log('deleting privacy from privacies', this.privacies);


        railing.hasPlanter = false;
        this.updateCanvas();
      }

      eventMouseenterPlanter(planter) {
        // console.log('eventHoverPlanter', planter);
        clearTimeout(this.planterTimeout);

        planter.hover = true;
      }

      getRailingFromPlanter(planter) {
        let railingId;
        for (let key in this.planters) {
          if (this.planters[key] === planter) {
            railingId = parseInt(key);
          }
        }
        if (railingId === undefined) {
          console.log('getRailingFromPlanter ERR: No railingId found')
        }
        for (let i = 0; i < this.railings.length; i++) {
          let railing = this.railings[i];
          if (railing._id === railingId) {
            return railing;
          }
        }
        // console.log('getRailingFromPlanter ERR: No railing found')
        return;
      }

      eventMouseleavePlanter(planter) {
        // console.log('eventLeavePlanter', planter);

        let children = this.planterGroup.children;
        let planterInGroup = false;
        // check if this planter is even still in the Konva tree
        for (let i = 0; i < children.length; i++) {
          if (children[i] === planter) {
            planterInGroup = true;
            // console.log('Planter in Group');
          }
        }
        if (!planterInGroup) return;

        planter.hover = false;
        let railing = this.getRailingFromPlanter(planter);
        this.removePlanter(railing);
      }


      eventClickPlanter(planter) {
        // console.log('eventSelectPlanter', planter);

        planter.isSelected = !planter.isSelected;
        planter.hover = false;
        let railing = this.getRailingFromPlanter(planter);

        this.removePlanter(railing);
      }


      /**
       *
       *
       */


      eventMouseenterPrivacy(privacy) {
        // console.log('eventHoverPlanter', planter);
        clearTimeout(this.privacyTimeout);

        privacy.hover = true;
      }

      getRailingFromPrivacy(privacy) {
        let railingId;
        for (let key in this.privacies) {
          if (this.privacies[key] === privacy) {
            railingId = parseInt(key);
          }
        }
        if (railingId === undefined) {
          console.log('getRailingFromprivacy ERR: No railingId found')
        }
        for (let i = 0; i < this.railings.length; i++) {
          let railing = this.railings[i];
          if (railing._id === railingId) {
            return railing;
          }
        }
        // console.log('getRailingFromprivacy ERR: No railing found')
        return;
      }

      eventMouseleavePrivacy(privacy) {
        console.log('eventLeaveprivacy', privacy);

        let children = this.privacyGroup.children;
        let privacyInGroup = false;
        // check if this privacy is even still in the Konva tree
        for (let i = 0; i < children.length; i++) {
          if (children[i] === privacy) {
            privacyInGroup = true;
            // console.log('privacy in Group');
          }
        }
        if (!privacyInGroup) return;

        privacy.hover = false;
        let railing = this.getRailingFromPrivacy(privacy);
        this.removePrivacy(railing);
      }

      eventClickPrivacy(privacy) {
        console.log('eventClickprivacy', privacy);

        privacy.isSelected = !privacy.isSelected;
        privacy.hover = false;
        let railing = this.getRailingFromPrivacy(privacy);

        this.removePrivacy(railing);
      }

    }


    let canvas = new Canvas();
    canvas.render();

  </script>
</body>

</html>