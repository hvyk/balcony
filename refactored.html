<!DOCTYPE html>
<html>
  <head>
    <script src="https://unpkg.com/konva@4.0.3/konva.min.js"></script>
    <meta charset="utf-8" />
    <title>Konva Simple Window drawing</title>
    <style>
      body {
        PADDING: 0;
        margin: 0;
        overflow: hidden;
      }

      #container {
        /* border: 1px solid grey; */
        /* background-color: lightgrey; */
        background-color: #fff;
      }

      #controls {
        position: absolute;
        top: 4px;
        left: 4px;
      }
    </style>
  </head>

  <body>
    <div id="container"></div>

    <div id="controls">
      <div style="float: left; PADDING: 10px">
        Length:
        <input type="number" id="widthInput" />
      </div>
      <div style="float: left; PADDING: 10px">
        Width:
        <input type="number" id="heightInput" />
      </div>
    </div>
    <script>

      // Constants
      const SCALE_FACTOR = 0.65;
      // const PADDING = 70; // mm

      // planter dimensions
      var PLANTER_WIDTH = 300;
      var PLANTER_LENGTH = 800;


      // // The class for corners in the rail
      class Corner {

        fill = 'white';
        stroke = 'black';
        strokeWidth = 1;

        constructor(x, y, width) {
          this.x = x;
          this.y = y;
          this.width = width;

          return this.toShape();
        }

        toShape() {
          let shape = new Konva.Rect({
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.width,
            fill: this.fill,
            stroke: this.stroke,
            strokeWidth: this.strokeWidth
          });
          return shape;
        }
      }


      // Container class for Konva Shapes
      class Frame {

        fill = '#EAEAEA';
        stroke = 'black';
        strokeWidth = 1;

        constructor(x, y, width, height) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;

          return this.toShape();
        }

        toShape() {
          let shape = new Konva.Rect({
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height,
            fill: this.fill,
            stroke: this.stroke,
            strokeWidth: this.strokeWidth
          });
          shape.on('mouseover', function() {
              console.log(`left Section Mouseover`);
          });
          return shape;
        }


      }


      class Canvas {

        PAD = 70;

        // parameters
        windowWidth;
        windowHeight;
        balconyWidth;
        balconyHeight;
        // stage;
        // layer;
        // widthInput;
        // heightInput;

        /**
         * Constructor
         *    Creates the stage and a layer, and adds the layer to the stage
         *    Add all the event listeners for the controls
         *    Renders the image
         */
        constructor() {

          // Canvas dimensions
          this.getWindowDimensions();
          // Get the balcony dimensions
          this.getBalconyDimensions();


          // Create the stage
          this.stage = new Konva.Stage({
            container: 'container',
            width: this.windowWidth,
            height: this.windowHeight
          });

          // Create the layer, and add it to the stage
          this.layer = new Konva.Layer();
          this.stage.add(this.layer);

          // Corners
          // this.cornerGroup = new Konva.Group();
          this.corners = [];

          // Railings 
          this.frames = []
          // Planters
          this.planters = [];

          // this.draw();
        }

        getWindowDimensions() {
          // Canvas dimensions
          this.windowWidth = window.innerWidth;
          this.windowHeight = window.innerHeight;
          //  console.log('Window: ', this.windowWidth, this.windowHeight);
        }

        getBalconyDimensions() {
          var urlParams = new URLSearchParams(window.location.search);
          this.balconyHeight = parseInt(urlParams.get('length'));
          this.balconyWidth = parseInt(urlParams.get('width'));
          console.log('Balcony: ', this.balconyWidth, this.balconyHeight);

        }

        render() {
          this.updateCanvas();
        }

        calculateWindowRatio() {
          let wr = this.stage.width() / this.balconyWidth;
          let hr = this.stage.height() / this.balconyHeight;
          return Math.min(wr, hr) * SCALE_FACTOR;
        }

        createBaseGroup(ratio) {
          let frameOnScreenWidth = this.balconyWidth * ratio;
          let frameOnScreenHeight = this.balconyHeight * ratio;

          var group = new Konva.Group({});

          group.x(Math.round(this.stage.width() / 2 - frameOnScreenWidth / 2) + 0.5);
          group.y(Math.round(this.stage.height() / 2 - frameOnScreenHeight / 2) + 0.5);
          return group;
        }

        updateCanvas() {
          console.log("updateCanvas")
          this.layer.children.destroy();

          let ratio = this.calculateWindowRatio();

          // Create base group and add it to stage.layer
          let baseGroup = this.createBaseGroup(ratio);
          this.layer.add(baseGroup);
    
          // Corners
          let cornerGroup = this.createCorners(ratio);
          baseGroup.add(cornerGroup);

          let frameGroup = this.createFrames(ratio);
          baseGroup.add(frameGroup);

          // // Top and bottom Frame
          // var frameGroup = this.createLengthFrame(frameWidth, frameHeight);
          // frameGroup.scale({ x: ratio, y: ratio });
          // group.add(frameGroup);
          
          // // Left and right Frame
          // frameGroup = this.createWidthFrame(frameWidth, frameHeight);
          // frameGroup.scale({ x: ratio, y: ratio });
          // group.add(frameGroup);

          this.layer.draw();
        }

        createCorners(ratio) {

        // Create the corners
        let topLeft = new Corner(0, 0, this.PAD);
        let topRight = new Corner(this.balconyWidth-this.PAD, 0, this.PAD);
        let bottomLeft = new Corner(0, this.balconyHeight-this.PAD, this.PAD);
        let bottomRight = new Corner(this.balconyWidth-this.PAD, this.balconyHeight-this.PAD, this.PAD);

        this.corners.push(topLeft);
        this.corners.push(topRight);
        this.corners.push(bottomLeft);
        this.corners.push(bottomRight);

        let cornerGroup = new Konva.Group();
        cornerGroup.add(topLeft, topRight, bottomLeft, bottomRight);
        cornerGroup.scale({ x: ratio, y: ratio });

        return cornerGroup;
      }

        createFrames(ratio) {

        let group = new Konva.Group();

        group.add(this.createWidthFrames());
        group.add(this.createHeightFrames());
        group.scale({ x: ratio, y: ratio });

        return group;
      }

        createWidthFrames() {

          let frameWidth = this.balconyWidth;
          let frameHeight = this.balconyHeight;

          var group = new Konva.Group();

          var topDim = frameWidth - (2 * this.PAD);
          var numSections = Math.floor(topDim / PLANTER_LENGTH);
          var remainder = topDim % (numSections * PLANTER_LENGTH )
          var sectionLength = remainder / numSections + PLANTER_LENGTH;

          for (let i = 0; i < numSections; i++) {

            let xOffset = this.PAD + (i*sectionLength);


            let top = new Frame(xOffset, 0, sectionLength, this.PAD);
            let bottom = new Frame(xOffset, this.balconyHeight-this.PAD, sectionLength, this.PAD);

            this.frames.push(top);
            this.frames.push(bottom);

            group.add(top, bottom);

          }

          group
            .find('Line')
            .stroke('black')
            .strokeWidth(1);

          return group;
        }

        createHeightFrames() {

          var group = new Konva.Group();

          // Some vars for easy calculations -  need numSections, and sectionLength
          var sideDim = this.balconyHeight - 2*this.PAD;
          var numSections = Math.floor(sideDim / PLANTER_LENGTH);
          var remainder = sideDim % (numSections * PLANTER_LENGTH )
          var sectionLength = remainder / numSections + PLANTER_LENGTH;

          for (let i = 0; i < numSections; i++) {

            let yOffset = this.PAD + (i*sectionLength);

            // Left and Right section
            let left = new Frame(0, yOffset, this.PAD, sectionLength);
            let right = new Frame(this.balconyWidth-this.PAD, yOffset, this.PAD, sectionLength);

            // Add to the frames array
            this.frames.push(left);
            this.frames.push(right);

            // Add to group
            group.add(left, right);
          }

          return group;
        }

      }


      let canvas = new Canvas();
      canvas.render();

    </script>
  </body>
</html>