<!DOCTYPE html>
<html>
  <head>
    <script src="https://unpkg.com/konva@4.0.3/konva.min.js"></script>
    <meta charset="utf-8" />
    <title>Konva Simple Window drawing</title>
    <style>
      body {
        PADDING: 0;
        margin: 0;
        overflow: hidden;
      }

      #container {
        /* border: 1px solid grey; */
        /* background-color: lightgrey; */
        background-color: #fff;
      }

      #controls {
        position: absolute;
        top: 4px;
        left: 4px;
      }
    </style>
  </head>

  <body>
    <div id="container"></div>

    <div id="controls">
      <div style="float: left; PADDING: 10px">
        Length:
        <input type="number" id="widthInput" />
      </div>
      <div style="float: left; PADDING: 10px">
        Width:
        <input type="number" id="heightInput" />
      </div>
    </div>
    <script>

      // Constants
      const SCALE_FACTOR = 0.65;
      // const PADDING = 70; // mm

      // planter dimensions
      var PLANTER_WIDTH = 160;
      var PLANTER_LENGTH = 800;


      // // // The class for corners in the rail
      // class Corner {

      //   fill = 'white';
      //   stroke = 'black';
      //   strokeWidth = 1;

      //   constructor(x, y, width) {
      //     this.x = x;
      //     this.y = y;
      //     this.width = width;

      //     // Return this, not this.shape
      //     return this.toShape();
      //   }

      //   toShape() {
      //     let shape = new Konva.Rect({
      //       x: this.x,
      //       y: this.y,
      //       width: this.width,
      //       height: this.width,
      //       fill: this.fill,
      //       stroke: this.stroke,
      //       strokeWidth: this.strokeWidth
      //     });
      //     return shape;
      //   }
      // }

      class Planter {

        isSelected = false;

        fill = '#a3c2c2';
        stroke = 'black';
        strokeWidth = 1;
        hover = true;

        constructor(railing) {

          this.railingId = railing.shape._id;

          if (railing.position === 'top') {
            this.x = railing.centreX-PLANTER_LENGTH/2;
            this.y = railing.centreY-railing.height/2-PLANTER_WIDTH;
            this.width = PLANTER_LENGTH;
            this.height = PLANTER_WIDTH;
          } else if (railing.position === 'bottom') {
            this.x = railing.centreX-PLANTER_LENGTH/2;
            this.y = railing.centreY+railing.height/2;
            this.width = PLANTER_LENGTH;
            this.height = PLANTER_WIDTH;
          } else if (railing.position === 'left') {
            this.x = railing.centreX-PLANTER_WIDTH-railing.width/2;
            this.y = railing.centreY-PLANTER_LENGTH/2;
            this.width = PLANTER_WIDTH;
            this.height = PLANTER_LENGTH;
          } else if (railing.position === 'right') {
            this.x = railing.centreX+railing.width/2;
            this.y = railing.centreY-PLANTER_LENGTH/2;
            this.width = PLANTER_WIDTH;
            this.height = PLANTER_LENGTH;
          }

          this.createShape();
        }
        createShape() {
          this.shape = new Konva.Rect({
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height,
            fill: this.fill,
            stroke: this.stroke,
            strokeWidth: this.strokeWidth
          });
          // TODO: onclick
          this.shape.on('click', function() {
            console.log('Planter.click');
            canvas.eventSelectPlanter(this);
          })
          this.shape.on('mouseenter', function() {
            canvas.eventHoverPlanter(this);
          })
          this.shape.on('mouseleave', function() {
            canvas.eventLeavePlanter(this);
          })
        }
        toShape() {
          return this.shape;
        }
      }

      class Privacy {

        fill = '#73264d';
        stroke = 'black';
        strokeWidth = 1;

        constructor(x, y, width, height) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
        }
        toShape() {
          let shape = new Konva.Rect({
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.width,
            fill: this.fill,
            stroke: this.stroke,
            strokeWidth: this.strokeWidth
          });
          return shape;
        }
      }


      class Corner extends Konva.Rect {

        constructor(x, y, width) {
          // Konva.Rect
          super({
            x: x,
            y: y,
            width: width,
            height: width,
            fill: 'white',
            stroke: 'black',
            strokeWidth: 1
          });
        }

        testFunction(arg) {
          console.log('testFunction: ', arg);
        }
      }

      // Container class for Konva Shapes
      class Railing {

        frameFill = '#EAEAEA';
        stroke = 'black';
        strokeWidth = 1;

        hasPlanter = false;

        planterFill = '#73264d';
        planterStroke = 'black';

        constructor(canvas, x, y, width, height, position) {
          this.canvas = canvas;
          
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          this.position = position;

          this.centreX = x + width/2;
          this.centreY = y + height/2;

          this.createShape();
        }

        // TODO: turn this into a group - which includes the rail, planter, privacy
        createShape() {
          this.shape = new Konva.Rect({
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height,
            fill: this.frameFill,
            stroke: this.stroke,
            strokeWidth: this.strokeWidth
          });
          this.shape.on('mouseenter', function() {
            console.log('Frame.mouseover');
            canvas.eventMouseoverRailing(this);
          });
          this.shape.on('mouseleave', function() {
            console.log('Frame.leave');
            canvas.eventMouseoffRailing(this);
          });
          // return shape;
        }

        toShape() {
          return this.shape;
        }

      }

      class Canvas {

        PAD = 70;

        // parameters
        windowWidth;
        windowHeight;
        balconyWidth;
        balconyHeight;

        constructor() {

          // Canvas dimensions
          this.getWindowDimensions();
          // Get the balcony dimensions
          this.getBalconyDimensions();

          // Create the stage
          this.stage = new Konva.Stage({
            container: 'container',
            width: this.windowWidth,
            height: this.windowHeight
          });

          // Create the layer, and add it to the stage
          this.layer = new Konva.Layer();
          this.stage.add(this.layer);

          // Corners
          // this.cornerGroup = new Konva.Group();
          this.corners = [];

          // Railings 
          this.railings = []
          // Planters
          this.planters = {}; // id: Planter (Konva.Rect)

          this.isInitialized = false;
        }

        getWindowDimensions() {
          // Canvas dimensions
          this.windowWidth = window.innerWidth;
          this.windowHeight = window.innerHeight;
          //  console.log('Window: ', this.windowWidth, this.windowHeight);
        }

        getBalconyDimensions() {
          var urlParams = new URLSearchParams(window.location.search);
          this.balconyHeight = parseInt(urlParams.get('length'));
          this.balconyWidth = parseInt(urlParams.get('width'));
          console.log('Balcony: ', this.balconyWidth, this.balconyHeight);

        }

        render() {
          if (!this.isInitialized) {
            this.initCanvas();
          } else {
            this.updateCanvas();
          }
          // let testShape = new TestShape()
          // testShape.testFunction('Woop');
        }

        updateCanvas() {
          // console.log('updateCanvas');
          this.layer.draw();
        }

        initCanvas() {
          console.log("initCanvas")
          this.layer.children.destroy();

          this.ratio = this.calculateWindowRatio();

          // Create base group and add it to stage.layer
          this.baseGroup = this.createBaseGroup(this.ratio);
          this.layer.add(this.baseGroup);
    
          // Corners
          let cornerGroup = this.createCorners(this.ratio);
          this.baseGroup.add(cornerGroup);

          // railings
          let frameGroup = this.createFrames(this.ratio);
          this.baseGroup.add(frameGroup);

          // planters
          this.planterGroup = new Konva.Group();
          this.baseGroup.add(this.planterGroup);

          this.isinitialize = true;

          this.layer.draw();
        }

        calculateWindowRatio() {
          let wr = this.stage.width() / this.balconyWidth;
          let hr = this.stage.height() / this.balconyHeight;
          return Math.min(wr, hr) * SCALE_FACTOR;
        }

        createBaseGroup(ratio) {
          let frameOnScreenWidth = this.balconyWidth * ratio;
          let frameOnScreenHeight = this.balconyHeight * ratio;

          var group = new Konva.Group({});

          group.x(Math.round(this.stage.width() / 2 - frameOnScreenWidth / 2) + 0.5);
          group.y(Math.round(this.stage.height() / 2 - frameOnScreenHeight / 2) + 0.5);
          return group;
        }

        createCorners(ratio) {

          // Create the corners
          let topLeft = new Corner(0, 0, this.PAD);
          let topRight = new Corner(this.balconyWidth-this.PAD, 0, this.PAD);
          let bottomLeft = new Corner(0, this.balconyHeight-this.PAD, this.PAD);
          let bottomRight = new Corner(this.balconyWidth-this.PAD, this.balconyHeight-this.PAD, this.PAD);

          this.corners.push(topLeft);
          this.corners.push(topRight);
          this.corners.push(bottomLeft);
          this.corners.push(bottomRight);

          let cornerGroup = new Konva.Group();
          cornerGroup.add(topLeft, topRight, bottomLeft, bottomRight);
          cornerGroup.scale({ x: ratio, y: ratio });

          return cornerGroup;
        }

        createFrames(ratio) {

          let group = new Konva.Group();

          group.add(this.createWidthFrames());
          group.add(this.createHeightFrames());
          group.scale({ x: ratio, y: ratio });

          return group;
        }

        createWidthFrames() {

          let frameWidth = this.balconyWidth;
          let frameHeight = this.balconyHeight;

          var group = new Konva.Group();

          var topDim = frameWidth - (2 * this.PAD);
          var numSections = Math.floor(topDim / PLANTER_LENGTH);
          var remainder = topDim % (numSections * PLANTER_LENGTH )
          var sectionLength = remainder / numSections + PLANTER_LENGTH;

          for (let i = 0; i < numSections; i++) {

            let xOffset = this.PAD + (i*sectionLength);

            let top = new Railing(this, xOffset, 0, sectionLength, this.PAD, 'top');
            let bottom = new Railing(this, xOffset, this.balconyHeight-this.PAD, sectionLength, this.PAD, 'bottom');

            this.railings.push(top);
            this.railings.push(bottom);

            group.add(top.toShape(), bottom.toShape());

          }

          return group;
        }

        createHeightFrames() {

          var group = new Konva.Group();

          // Some vars for easy calculations -  need numSections, and sectionLength
          var sideDim = this.balconyHeight - 2*this.PAD;
          var numSections = Math.floor(sideDim / PLANTER_LENGTH);
          var remainder = sideDim % (numSections * PLANTER_LENGTH )
          var sectionLength = remainder / numSections + PLANTER_LENGTH;

          for (let i = 0; i < numSections; i++) {

            let yOffset = this.PAD + (i*sectionLength);

            // Left and Right section
            let left = new Railing(this, 0, yOffset, this.PAD, sectionLength, 'left');
            let right = new Railing(this, this.balconyWidth-this.PAD, yOffset, this.PAD, sectionLength, 'right');

            // Add to the railings array
            this.railings.push(left);
            this.railings.push(right);

            // Add to group
            group.add(left.toShape(), right.toShape());
          }

          return group;
        }

        getRailingFromRailingShape(shape) {
          this.railings.forEach(railing => {
            if (railing.shape._id === shape._id) {
              return railing;
            }
          })
          console.log('getRailingFromRailingShape failed');
        }

        // getRailingFromPlanterShape(shape) {
        //   // get the proper Planter shape
        //   this.planters.forEach(planter => {
        //     if () {

        //     }
        //   })
        // }

        eventMouseoverRailing(railingShape) {
          console.log('eventMouseoverRailing');

          let railing;

          // display the respective Planter and Privacy
          for (let i = 0; i < this.railings.length; i++) {
            if (this.railings[i].shape._id === railingShape._id) {
              console.log('its a match!');
              railing = this.railings[i];
            }
          }

          if (!railing.hasPlanter) {
            let planter = new Planter(railing);
            
            this.planters[planter.railingId] = planter;
            console.log(this.planters);

            this.planterGroup.add(planter.toShape());
            this.planterGroup.scale({ x: this.ratio, y: this.ratio });
            this.baseGroup.add(this.planterGroup);

            this.updateCanvas();
          }
          railing.hasPlanter = true;
        }

        eventMouseoffRailing(obj) {
          console.log('eventMouseoffRailing');

          setTimeout((obj) => {
            console.log('setTimeout callback with obj: ', obj)

            let planter = this.planters[obj._id];

              if (planter && !planter.hover) {
                console.log('removingPlanter');
                this.removePlanter(obj);

              }
          }, 2000, obj);
        }

        // removePlanterFromFrame(railings)
        removePlanter(railings) {
          let planter = this.planters[railings.shape._id];
              let railing;

              if (planter.isSelected) {
                return;
              }

              // Remove planter from this.planters
              if (!this.planters[railings.shape._id].isSelected) {
                delete this.planters[railings._id];
              }
              this.planterGroup.children.forEach(child => {
                this.planterGroup.destroy(child);
              });

              // display the respective Planter and Privacy
              for (let i = 0; i < this.railings.length; i++) {
                if (this.railings[i].shape._id === railings._id) {
                  console.log('its a match!');
                  railing = this.railings[i];
                }
              }

              railing.hasPlanter = false;
              this.updateCanvas();
        }

        eventHoverPlanter(obj) {
          console.log('eventHoverPlanter', obj);

          // let planter = this.planters[obj._id];
          // planter.hover = true;

          if (this.planters[obj._id]) {
            this.planters[obj._id].hover = true;
          }
        }

        eventLeavePlanter(obj) {
          // Remove this planter
          // this.parent.destroy(this);

          let railingId;
          // get railingId from planter
          for (let key in this.planters) {
            if (this.planters[key].shape._id === obj._id) {
              console.log('Ids match!:', this.planters[key].shape._id, obj._id);
              railingId = this.planters[key].railingId;
            }
          }
          // console.log('leavePlanter railingId: ', railingId);

          // if (this.planters[railingId]) {
          //   console.log('eventLeavePlanter: its a match');
          //   this.planters[railingId].hover = false;
          // }

          let railing;
          for (let i = 0; i < this.railings.length; i++) {
            if (this.railings[i].shape._id === railingId) {
              console.log('eventLeavePlanter: its a match!');
              railing = this.railings[i];
            }
          }

          this.removePlanter(railing);

          obj.destroy();
          this.updateCanvas();
        }

        eventSlectePlanter(obj) {
          console.log(this.planters[obj._id]);
        }

      }


      let canvas = new Canvas();
      canvas.render();

    </script>
  </body>
</html>