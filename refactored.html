<!DOCTYPE html>
<html>
  <head>
    <script src="https://unpkg.com/konva@4.0.3/konva.min.js"></script>
    <meta charset="utf-8" />
    <title>Konva Simple Window drawing</title>
    <style>
      body {
        PADDING: 0;
        margin: 0;
        overflow: hidden;
      }

      #container {
        /* border: 1px solid grey; */
        /* background-color: lightgrey; */
        background-color: #fff;
      }

      #controls {
        position: absolute;
        top: 4px;
        left: 4px;
      }
    </style>
  </head>

  <body>
    <div id="container"></div>

    <div id="controls">
      <div style="float: left; PADDING: 10px">
        Length:
        <input type="number" id="widthInput" />
      </div>
      <div style="float: left; PADDING: 10px">
        Width:
        <input type="number" id="heightInput" />
      </div>
    </div>
    <script>

      // Constants
      const SCALE_FACTOR = 0.65;
      const PADDING = 70; // mm

      // planter dimensions
      var PLANTER_WIDTH = 300;
      var PLANTER_LENGTH = 800;


      // // The class for corners in the rail
      // class Corner {

      //   constructor(canvas) {
      //     this.canvas = canvas;
      //   }

      //   setDimensions(x, y, width) {
      //     this.x = x;
      //     this.y = y;
      //     this.width = width;
      //   }

      //   draw() {

      //     canvas.render();
      //   }
      // }

      class Canvas {

        // parameters
        windowWidth;
        windowHeight;
        balconyWidth;
        balconyHeight;
        // stage;
        // layer;
        // widthInput;
        // heightInput;

        /**
         * Constructor
         *    Creates the stage and a layer, and adds the layer to the stage
         *    Add all the event listeners for the controls
         *    Renders the image
         */
        constructor() {
          // Canvas dimensions
          this.getWindowDimensions();

          // Create the stage
          this.stage = new Konva.Stage({
            container: 'container',
            width: this.windowWidth,
            height: this.windowHeight
          });

          // Create the layer, and add it to the stage
          this.layer = new Konva.Layer();
          this.stage.add(this.layer);

          // Get the balcony dimensions
          this.getBalconyDimensions();

          // Corners
          this.corners = [];
          // Railings 
          this.railings = []
          // Planters
          this.planters = [];

          // this.draw();
        }


        getWindowDimensions() {
          // Canvas dimensions
          this.windowWidth = window.innerWidth;
          this.windowHeight = window.innerHeight;
          //  console.log('Window: ', this.windowWidth, this.windowHeight);
        }


        getBalconyDimensions() {
          var urlParams = new URLSearchParams(window.location.search);
          this.balconyHeight = parseInt(urlParams.get('length'));
          this.balconyWidth = parseInt(urlParams.get('width'));
          console.log('Balcony: ', this.balconyWidth, this.balconyHeight);

        }

        render() {
          this.updateCanvas();
        }

        // renderCorners() {
        //   console.log('renderCorners');
        // }

        // renderRailings() {
        //   console.log('renderRailings');
        // }
        // renderPlanters() {
        //   console.log('renderPlanters');
        // }



        calculateWindowRatio() {
          let wr = this.stage.width() / this.balconyWidth;
          let hr = this.stage.height() / this.balconyHeight;
          return Math.min(wr, hr) * SCALE_FACTOR;
        }

        createBaseGroup(ratio) {
          let frameOnScreenWidth = this.balconyWidth * ratio;
          let frameOnScreenHeight = this.balconyHeight * ratio;

          var group = new Konva.Group({});

          group.x(Math.round(this.stage.width() / 2 - frameOnScreenWidth / 2) + 0.5);
          group.y(Math.round(this.stage.height() / 2 - frameOnScreenHeight / 2) + 0.5);
          return group;
        }


        updateCanvas() {
          console.log("updateCanvas")
          this.layer.children.destroy();

          // TODO: make these class variables
          var frameWidth = this.balconyWidth;
          var frameHeight = this.balconyHight;

          // var wr = this.stage.width() / frameWidth;
          // var hr = this.stage.height() / frameHeight;
          // var ratio = Math.min(wr, hr) * SCALE_FACTOR;
          let ratio = this.calculateWindowRatio();

          // let frameOnScreenWidth = this.balconyWidth * ratio;
          // let frameOnScreenHeight = this.balconyHeight * ratio;

          let group = this.createBaseGroup(ratio);
          // var group = new Konva.Group({});

          // group.x(Math.round(this.stage.width() / 2 - frameOnScreenWidth / 2) + 0.5);
          // group.y(Math.round(this.stage.height() / 2 - frameOnScreenHeight / 2) + 0.5);

          this.layer.add(group);
    
          // Corners
          // let frameGroup = this.createCorners(frameWidth, frameHeight);
          let frameGroup = this.createCorners();

          // // create the corner objects and push to array
          // this.createCorners();
          // // create the framegroup from the corners array
          // let frameGroup = drawCorners()

  
          frameGroup.scale({ x: ratio, y: ratio });
          group.add(frameGroup);

          // // Top and bottom Frame
          // var frameGroup = this.createLengthFrame(frameWidth, frameHeight);
          // frameGroup.scale({ x: ratio, y: ratio });
          // group.add(frameGroup);
          
          // // Left and right Frame
          // frameGroup = this.createWidthFrame(frameWidth, frameHeight);
          // frameGroup.scale({ x: ratio, y: ratio });
          // group.add(frameGroup);

          this.layer.draw();
        }



      // Draws the four corners of the rectangular balcony
      createCorners() {

        let frameWidth = this.balconyWidth;
        let frameHeight = this.balconyHeight;

        var PADDING = 70;   // width of frame
        var group = new Konva.Group();

        var topLeft = new Konva.Line({
          points: [
            0,       0,
            PADDING, 0,
            PADDING, PADDING,
            0,       0,
            0,       PADDING,
            PADDING, PADDING,
          ],
          fill: 'white'
        });

        var topRight = new Konva.Line({
          points: [
            frameWidth, 0,
            frameWidth-PADDING, 0,
            frameWidth-PADDING, PADDING,
            frameWidth, 0,
            frameWidth, PADDING,
            frameWidth-PADDING, PADDING,
          ],
          fill: 'white'
        });

        var bottomRight = new Konva.Line({
          points: [
            frameWidth,         frameHeight,
            frameWidth-PADDING, frameHeight,
            frameWidth-PADDING, frameHeight-PADDING,
            frameWidth,         frameHeight,
            frameWidth,         frameHeight-PADDING,
            frameWidth-PADDING, frameHeight-PADDING,
          ],
          fill: 'white'
        });

        var bottomLeft = new Konva.Line({
          points: [
            0,       frameHeight,
            PADDING, frameHeight,
            PADDING, frameHeight-PADDING,
            0,       frameHeight,
            0,       frameHeight-PADDING,
            PADDING, frameHeight-PADDING,
          ],
          fill: 'white'
        });

        group.add(topLeft, topRight, bottomRight, bottomLeft);

        group
          .find('Line')
          // .closed(true)
          .stroke('black')
          .strokeWidth(1);

        return group;
      }

      /**
       * Create Frame
       */
       createLengthFrame(frameWidth, frameHeight) {

          var PADDING = 70;   // width of frame
          var group = new Konva.Group();

          var topDim = frameWidth - 2*PADDING;
          var numSections = Math.floor(topDim / PLANTER_LENGTH);
          var remainder = topDim % (numSections * PLANTER_LENGTH )
          var sectionLength = remainder / numSections + PLANTER_LENGTH;

          for (let i = 0; i < numSections; i++) {
            // console.log('draw section ', i)

            let xOffset = PADDING + (i*sectionLength);
            // draw the top section
            var topSection = new Konva.Line({
              points: [
                xOffset, 0,
                xOffset + sectionLength, 0,
                xOffset + sectionLength, PADDING,
                xOffset, PADDING,
                xOffset, 0,
              ],
              fill: 'white'
            });

            var topSectionFill = new Konva.Rect({
              x: xOffset,
              y: 0,
              width: sectionLength,
              height: PADDING,
              fill: '#EAEAEA'
            });
            topSectionFill.on('mouseover', function() {
              console.log(`top Section ${i} Mouseover`);
            });

            var bottomSection = new Konva.Line({
              points: [
                xOffset, frameHeight-PADDING,
                xOffset + sectionLength, frameHeight-PADDING,
                xOffset + sectionLength, frameHeight,
                xOffset, frameHeight,
                xOffset, frameHeight-PADDING,
              ],
              fill: 'white'
            });

            var bottomSectionFill = new Konva.Rect({
              x: xOffset,
              y: frameHeight-PADDING,
              width: sectionLength,
              height: PADDING,
              fill: '#EAEAEA'
            });
            bottomSectionFill.on('mouseover', function() {
              console.log(`top Section ${i} Mouseover`);
            });

            group.add(topSection, topSectionFill, bottomSection, bottomSectionFill);

          }

          group
            .find('Line')
            .stroke('black')
            .strokeWidth(1);

          return group;
        }

      /**
       * Create Frame
       */
      createWidthFrame(frameWidth, frameHeight) {

          var PADDING = 70;   // width of frame
          var group = new Konva.Group();

          var sideDim = frameHeight - 2*PADDING;
          var numSections = Math.floor(sideDim / PLANTER_LENGTH);
          var remainder = sideDim % (numSections * PLANTER_LENGTH )
          var sectionLength = remainder / numSections + PLANTER_LENGTH;

          for (let i = 0; i < numSections; i++) {

            let yOffset = PADDING + (i*sectionLength);

            // draw the left section and fill it
            var leftSection = new Konva.Line({
              points: [
                0,           yOffset,
                0 + PADDING, yOffset,
                0 + PADDING, yOffset + sectionLength,
                0, yOffset + sectionLength,
                0, 0,
              ],
              fill: 'white'
            });

            var leftSectionFill = new Konva.Rect({
              x: 0,
              y: yOffset,
              width: PADDING,
              height: sectionLength,
              fill: '#EAEAEA'
            });         
            leftSectionFill.on('mouseover', function() {
              console.log(`left Section ${i} Mouseover`);
            });

            // draw the left section and fill it
            var rightSection = new Konva.Line({
              points: [
                frameWidth-PADDING,           yOffset,
                frameWidth-PADDING + PADDING, yOffset,
                frameWidth-PADDING + PADDING, yOffset + sectionLength,
                frameWidth-PADDING, yOffset + sectionLength,
                frameWidth-PADDING, 0,
              ],
              fill: 'white'
            });

            var rightSectionFill = new Konva.Rect({
              x: frameWidth-PADDING,
              y: yOffset,
              width: PADDING,
              height: sectionLength,
              fill: '#EAEAEA'
            });
            rightSectionFill.on('mouseover', function() {
              console.log(`right Section ${i} Mouseover`);
            });

            group.add(leftSection, leftSectionFill, rightSection, rightSectionFill);
          }

          group
            .find('Line')
            // .closed(true)
            .stroke('black')
            .strokeWidth(1);

          return group;
        }

      }


      let canvas = new Canvas();
      canvas.render();

    </script>
  </body>
</html>